from telethon import TelegramClient
from telethon.events import NewMessage
from telethon.tl.types import MessageEntityTextUrl, MessageEntityUrl

# from os import system, name
# from time import ctime as timeStamp
from asyncio import run, sleep, CancelledError
from utils import parse_url
from datetime import datetime
from logging import basicConfig, info, warning, error, DEBUG
from logging.handlers import RotatingFileHandler
import logging

# # Configure logging
# basicConfig(
#     filename=f"./logs/{(datetime.now()).strftime('%d-%b-%y %H-%M')}.txt",
#     level=DEBUG,
#     format="%(asctime)s %(levelname)s: %(message)s",
#     datefmt="%Y %b %d %H:%M:%S",
# )

# Clear previous logs
# system("cls" if name == "nt" else "clear")

# Use your own values from my.telegram.org
api_id = 20340026
api_hash = "d1c2010562443ded33c1f4fa64f16bc4"
client = TelegramClient("anon", api_id, api_hash)
amazon_affiliate_id = "dualwarez-21"
channels_id = [
    1315464303,
    1491489500,
    810184328,
    1714047949,
]  # channels id that we want to recieve msgs from
our_channel_id = -980741307  # our channel id where we want to forward msg


# listen for new message
@client.on(NewMessage(chats=channels_id, incoming=True, forwards=False))
async def handle_new_message(event):
    try:
        info("Recieved new message..")

        is_amazon_link = False

        for entity in event.message.entities:
            url = False

            if isinstance(entity, MessageEntityUrl):
                url = event.message.raw_text[
                    entity.offset : entity.offset + entity.length
                ]
            elif isinstance(entity, MessageEntityTextUrl):
                url = entity.url
            else:
                break

            if url:
                parsed_url = await parse_url(url, amazon_affiliate_id)
                is_amazon_link = parsed_url["is_amazon_link"]

                if is_amazon_link:
                    new_message = event.message.text.replace(url, parsed_url["updated"])
                    event.message.text = new_message

        if is_amazon_link:
            info("Sending ")
            await client.send_message(our_channel_id, event.message)
            info("Message send!")
        else:
            warning("Cannot found amazon link.")
            print("Cannot found amazon link.")

    except Exception as exception:
        error({"message": event.message, "event": event, "error": exception})
        print("Error occured! Check logs for more.")
        pass


async def main(restart_time=3600):
    while True:
        # Configure logging
        timeStamp = (datetime.now()).strftime("%d-%b-%y %H%M%S")
        
        logger = logging.getLogger()
        logger.setLevel(logging.DEBUG)
        # Create a rotating file handler
        file_handler = RotatingFileHandler(f"{timeStamp}.txt", backupCount=5)
        file_handler.setLevel(logging.DEBUG)


        # Create a formatter for the log messages
        formatter = logging.Formatter(
            "%(asctime)s %(levelname)s: %(message)s", datefmt="%Y-%m-%d %H:%M:%S"
        )

        # Add the formatter to the file handler
        file_handler.setFormatter(formatter)

        # Add the file handler to the logger
        logger.addHandler(file_handler)

        # basicConfig(
        #     filename=f"./logs/{timeStamp}.txt",
        #     level=DEBUG,
        #     format="%(asctime)s %(levelname)s: %(message)s",
        #     datefmt="%Y %b %d %H:%M:%S",
        # )

        # await client.start()

        # if client.is_connected:
        #     info("Connected!")

        await sleep(restart_time)

        # await client.disconnect()

        # if client.disconnected:
        #     info("Disconnected")
        #     await sleep(1.0)


try:
    run(main(5))
except (CancelledError, KeyboardInterrupt):
    print("Keyboard Interrupted!")
    pass
